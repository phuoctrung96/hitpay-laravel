<?php

namespace App\Business;

use App\Business;
use App\Enumerations\Business\Channel as BusinessChannel;
use App\Enumerations\Business\ChargeStatus;
use App\Enumerations\Business\PaymentMethodType;
use App\Enumerations\Business\PluginProvider;
use App\Enumerations\PaymentProvider as PaymentProviderEnum;
use App\Events\Business\RecurrentChargeSucceeded;
use App\Events\Business\SuccessCharge;
use App\Events\ChargeSucceeded;
use App\Jobs\CheckChargeForCashback;
use App\Jobs\Wallet\Receive as ReceiveFromCharge;
use App\Notifications\NotifyAdminAboutNewCharge;
use App\Notifications\NotifySuccessfulPayment;
use Carbon\Carbon;
use Exception;
use HitPay\Agent\LogHelpers;
use HitPay\Business\Charge\Calculator;
use HitPay\Business\Contracts\Chargeable;
use HitPay\Business\Contracts\HasCustomer as HasCustomerContract;
use HitPay\Business\Contracts\Ownable as OwnableContract;
use HitPay\Business\HasCustomer;
use HitPay\Business\Ownable;
use HitPay\Data\Objects\PaymentMethods\Card;
use HitPay\Model\UsesUuid;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Database\Eloquent\Relations\MorphTo;
use Illuminate\Notifications\Notifiable;
use Illuminate\Support\Facades;
use Illuminate\Support\Str;
use Throwable;

/**
 * Class Charge
 *
 * @package App\Business
 *
 * @property array $plugin_data
 * @property array $request_data
 * @property Invoice|null $invoice
 * @property PaymentRequest $paymentRequest
 * @property string payment_provider_charge_method
 * @property float amount
 * @property Business business
 * @property string currency
 * @property mixed closed_at
 */
class Charge extends Model implements HasCustomerContract, OwnableContract
{
    use HasCustomer, LogHelpers, Notifiable, Ownable, UsesUuid;

    /**
     * @var string[]
     */
    public const REMOVING_FIELDS = [
        'customer_billing_address1',
        'customer_billing_address2',
        'customer_billing_city',
        'customer_billing_company',
        'customer_billing_country',
        'customer_billing_phone',
        'customer_billing_state',
        'customer_billing_zip',
        'customer_phone',
        'customer_shipping_address1',
        'customer_shipping_address2',
        'customer_shipping_city',
        'customer_shipping_country',
        'customer_shipping_first_name',
        'customer_shipping_last_name',
        'customer_shipping_zip',
    ];

    /**
     * The database table used by the model.
     *
     * @var string
     */
    protected $table = 'business_charges';

    /**
     * The number of models to return for pagination.
     *
     * @var int
     */
    protected $perPage = 25;

    /**
     * The attributes that should be cast to native types.
     *
     * @var array
     */
    protected $casts = [
        'amount' => 'int',
        'fixed_fee' => 'int',
        'discount_fee' => 'int',
        'discount_fee_rate' => 'float',
        'data' => 'array',
        'plugin_data' => 'array',
        'expires_at' => 'datetime',
        'closed_at' => 'datetime',
    ];

    protected $guarded = [
        //
    ];
    public const stripe_methods = array('cards','wechatpay','alipay','grabpay' ,'charges', 'card_present', 'card', 'wechat');
    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        static::saving(function (self $model) {
            if ($model->payment_provider === 'hitpay') {
                if (is_null($model->payment_provider_account_id)) {
                    $model->setAttribute('payment_provider_account_id', $model->getAttribute('business_id'));
                }

                if (is_null($model->payment_provider_charge_id)) {
                    $model->setAttribute('payment_provider_charge_id', $model->getAttribute('id'));
                }

                if (is_null($model->payment_provider_charge_type)) {
                    $model->setAttribute('payment_provider_charge_type', 'business_charge');
                }
            }
        });

        static::saved(function (self $model) {
            if ($model->isDirty('status') && $model->status === ChargeStatus::SUCCEEDED) {
                // works for PayNow DBS & Shopee)
                if (Str::startsWith($model->payment_provider_charge_id, 'DICN') ||
                  $model->payment_provider_charge_method === 'direct_debit' ||
                  $model->payment_provider === PaymentProviderEnum::SHOPEE_PAY ||
                  $model->payment_provider === PaymentProviderEnum::GRABPAY ||
                  $model->payment_provider === PaymentProviderEnum::ZIP) {
                    try {
                        if ($model->getOriginal('status') !== ChargeStatus::REFUNDED) {
                            ReceiveFromCharge::dispatch($model);
                        }
                    } catch (Throwable $exception) {
                        Facades\Log::critical("Dispatch job to confirm charge and update wallet failed. Error: {$exception->getMessage()} ({$exception->getFile()}:{$exception->getLine()})\n{$exception->getTraceAsString()}");
                    }
                }

                try {
                    Facades\Notification::route('slack', config('services.slack.new_charges'))
                        ->notify(new NotifyAdminAboutNewCharge($model));
                } catch (Throwable $exception) {
                    // Do nothing if failed.
                }

                try {
                    $model->business->notify(new NotifySuccessfulPayment($model));
                } catch (Throwable $exception) {
                    Facades\Log::critical("Notifying '{$model->business->name}' failed for successful charge #{$model->getKey()}: {$exception->getMessage()} ({$exception->getFile()}:{$exception->getLine()})");
                }

                if ($model->channel === BusinessChannel::RECURRENT){
                    try {
                        event(new RecurrentChargeSucceeded($model));
                    } catch (Throwable $exception) {
                        Facades\Log::critical("Dispatching job 'ChargeSucceeded' failed for charge #{$model->getKey()}: {$exception->getMessage()} ({$exception->getFile()}:{$exception->getLine()})");
                    }
                }

                if (in_array($model->channel, [
                    BusinessChannel::PAYMENT_GATEWAY,
                    BusinessChannel::STORE_CHECKOUT,
                ])) {
                    if ($model->channel === BusinessChannel::PAYMENT_GATEWAY) {
                        try {
                            ChargeSucceeded::dispatch($model);
                        } catch (Throwable $exception) {
                            Facades\Log::critical("Dispatching job 'ChargeSucceeded' failed for charge #{$model->getKey()}: {$exception->getMessage()} ({$exception->getFile()}:{$exception->getLine()})");
                        }

                        try {
                            event(new SuccessCharge($model));
                        } catch (Throwable $exception) {
                            Facades\Log::critical("Dispatching job 'SuccessCharge' failed for charge #{$model->getKey()}: {$exception->getMessage()} ({$exception->getFile()}:{$exception->getLine()})");
                        }
                    }

                    if ($model->payment_provider_charge_method === PaymentMethodType::PAYNOW) {
                        try {
                            $job = new CheckChargeForCashback($model);
                            $job->delay(Carbon::now()->addSeconds(3));

                            dispatch($job);
                        } catch (Throwable $exception) {
                            Facades\Log::critical("Dispatch job to check charge for charge #{$model->getKey()} cashback failed. Error: {$exception->getMessage()} ({$exception->getFile()}:{$exception->getLine()})");
                        }
                    }
                }
            }
        });
    }

    /**
     * Apply calculator to fill in the attributes.
     *
     * @param \HitPay\Business\Charge\Calculator $calculator
     *
     * @return $this
     * @throws \App\Exceptions\HitPayLogicException
     */
    public function applyCalculator(Calculator $calculator) : self
    {
        $paymentProvider = $calculator->paymentProvider();

        $this->payment_provider = $paymentProvider->payment_provider;
        $this->payment_provider_account_id = $paymentProvider->payment_provider_account_id;
        $this->payment_provider_charge_method = $calculator->method();
        $this->payment_provider_charge_type = $calculator->type();
        $this->channel = $calculator->channel();
        $this->currency = $calculator->currency();
        $this->amount = $calculator->rawAmount();
        $this->fixed_fee = $calculator->fixedAmountRateFee();
        $this->discount_fee = $calculator->rawPercentageRateFee();
        $this->discount_fee_rate = $calculator->percentageRate();

        return $this;
    }

    public function customer() : BelongsTo
    {
        return $this->belongsTo(Customer::class, 'business_customer_id', 'id');
    }

    /**
     * Get the target of the charge.
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphTo|\Illuminate\Database\Eloquent\Model
     */
    public function target() : MorphTo
    {
        return $this->morphTo('target', 'business_target_type', 'business_target_id');
    }

    /**
     * Get the payment intents.
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany|\App\Business\PaymentIntent|\App\Business\PaymentIntent[]
     */
    public function paymentIntents() : HasMany
    {
        return $this->hasMany(PaymentIntent::class, 'business_charge_id', 'id');
    }

    /**
     * Get the refund intents.
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany|\App\Business\RefundIntent|\App\Business\RefundIntent[]
     */
    public function refundIntents() : HasMany
    {
        return $this->hasMany(RefundIntent::class, 'business_charge_id', 'id');
    }

    /**
     * Get the involving wallet transactions.
     *
     * @return \Illuminate\Database\Eloquent\Relations\MorphMany
     */
    public function walletTransactions() : MorphMany
    {
        return $this->morphMany(Wallet\Transaction::class, 'relatable', null, null, 'id');
    }

    /**
    * Checks if charge can be refunded
    *
    * @return bool
    */
    public function canRefund () : bool {
      if ($this->status === ChargeStatus::SUCCEEDED) {
        switch ($this->payment_provider) {
          case PaymentProviderEnum::SHOPEE_PAY:
          case PaymentProviderEnum::GRABPAY:
            // For Shopee Pay check if transaction was confirmed, i.e. moved to available wallet
            $transaction = $this->walletTransactions()->first();
            return $transaction && $transaction->confirmed;

          default:
            return true;
        }
      } else {
        return false;
      }
    }

    /**
     * Indicate if the charge is a destination charge.
     *
     * @return bool
     */
    public function isDestinationCharge() : bool
    {
        return $this->payment_provider_transfer_type === Calculator::DESTINATION;
    }

    /**
     * Indicate if the charge is a direct charge.
     *
     * @return bool
     */
    public function isDirectCharge() : bool
    {
        return $this->payment_provider_transfer_type === Calculator::DIRECT;
    }

    /**
     * Get the total fee of the charge.
     *
     * @return int
     */
    public function getTotalFee() : int
    {
        // This is returning the fee for destination charge in home currency.

        return $this->fixed_fee + $this->discount_fee + $this->home_currency_commission_amount;
    }

    public function getCommission() : int
    {
        return $this->home_currency_commission_amount;
    }

    /**
     * Get the application fee of the charge.
     *
     * @return int
     */
    public function getApplicationFee() : int
    {
        // This is returning the fee for direct charge in charge currency.

        return $this->fixed_fee;
    }

    /**
     * @param \HitPay\Business\Contracts\Chargeable|\Illuminate\Database\Eloquent\Model $chargeable
     */
    public function setChargeable(Chargeable $chargeable)
    {
        $this->target()->associate($chargeable);

        $this->channel = $chargeable->getChannel();
        $this->currency = $chargeable->getCurrency();
        $this->amount = $chargeable->getAmount();

        $this->business_customer_id = $chargeable->business_customer_id;
        $this->customer_name = $chargeable->customer_name;
        $this->customer_email = $chargeable->customer_email;
        $this->customer_phone_number = $chargeable->customer_phone_number;
        $this->customer_street = $chargeable->customer_street;
        $this->customer_city = $chargeable->customer_city;
        $this->customer_state = $chargeable->customer_state;
        $this->customer_postal_code = $chargeable->customer_postal_code;
        $this->customer_country = $chargeable->customer_country;
    }

    /**
     * @param $attribute
     *
     * @return mixed|string|null
     * @throws \Exception
     */
    public function display($attribute)
    {
        switch ($attribute) {

            case 'address':
                $address = implode(', ', array_filter([
                    $this->customer_street,
                    $this->customer_city,
                    $this->customer_state,
                    $this->customer_country,
                ]));

                if ($address === '') {
                    return '';
                }

                return $address.'. '.$this->customer_postal_code;

            case 'all_inclusive_fee':
                return $this->home_currency ? getFormattedAmount($this->home_currency, $this->getTotalFee()) : null;

            case 'all_inclusive_fee_original_currency':
                return $this->home_currency && $this->home_currency !== $this->currency ?
                    getFormattedAmount($this->currency, bcdiv((string) $this->getTotalFee(), (string) $this->exchange_rate, 2))
                    : null;

            case 'commission':
                return $this->home_currency ? getFormattedAmount($this->home_currency, $this->commission_amount) : null;

            case 'amount':
                return getFormattedAmount($this->currency, $this->amount);

            case 'balance':
                return getFormattedAmount($this->currency, $this->balance ?? 0);

            case 'refunded_amount':
                return getFormattedAmount($this->currency, $this->refunds()->where('is_cashback',0)->where('is_campaign_cashback',0)->sum('amount'));
            case 'cashback_amount':
                return getFormattedAmount($this->currency, $this->refunds->where('is_cashback',1)->first()->amount);
            case 'customer_name':
                return $this->customer_name ?? 'Customer';
            case 'shop_name':
                return $this->plugin_data['shop_name'] ?? null;
            case 'store_url':
                return $this->getStoreURL() ?? null;
        }

        throw new Exception('Invalid attribute.');
    }

    public function getStoreURL()
    {
        $paymentRequest = $this->paymentRequest()->first();

        if (!$paymentRequest) return null;

        $redirectUrl = $paymentRequest->redirect_url;

        if ($redirectUrl == "") return null;

        $parse = parse_url($redirectUrl);

        return $parse['host'];
    }

    public function transfers() : HasMany
    {
        return $this->hasMany(Transfer::class, 'business_charge_id', 'id');
    }

    /**
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany|\App\Business\Transfer|\App\Business\Transfer[]
     */
    public function fastTransfers() : BelongsToMany
    {
        return $this->belongsToMany(Transfer::class, 'business_charge_transfer', 'charge_id', 'transfer_id', 'id', 'id',
            'fastTransfers');
    }

    /**
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany|\App\Business\Transfer|\App\Business\Transfer[]
     */
    public function commissions() : BelongsToMany
    {
        return $this->belongsToMany(Commission::class, 'business_charge_commission', 'charge_id', 'commission_id', 'id', 'id',
            'fastTransfers');
    }

    public static function getPaymentMethodName(string $code): string
    {
        if($code == 'stripe') {
            return 'Stripe';
        }

        if($code == 'cash') {
            return  'Cash';
        }

        if($code == 'paynow') {
            return 'PayNow (Log)';
        }

        if($code == 'paynow_online') {
            return 'PayNow Online';
        }

        return 'Unknown';
    }

    public function getPaymentProviderCode(): string
    {
        if ($this->payment_provider === 'hitpay') {
            return $this->payment_provider_charge_method;
        } elseif ($this->payment_provider === \App\Enumerations\PaymentProvider::DBS_SINGAPORE) {
            return $this->payment_provider_charge_method;
        } elseif ($this->payment_provider == 'stripe_sg' && !empty($this->payment_provider_charge_method)) {
            return 'stripe';
        } else {
            return  'unknown';
        }
    }

    public function getChargeDetails() : string
    {
        if ($this->payment_provider === 'hitpay') {
            if ($this->payment_provider_charge_method === 'cash') {
                $method = 'Cash';
            } elseif ($this->payment_provider_charge_method === 'paynow') {
                $method = 'PayNow (Log)';
            } else {
                $method = $this->payment_provider_charge_method;
            }
        } elseif ($this->payment_provider === \App\Enumerations\PaymentProvider::DBS_SINGAPORE) {
            if ($this->payment_provider_charge_method === 'paynow_online') {
                $method = 'PayNow Online';
            } elseif ($this->payment_provider_charge_method === 'direc_debit') {
                $method = 'Direct Debit';
            } else {
                $method = $this->payment_provider_charge_method;
            }
        } elseif ($this->payment_provider_charge_method === PaymentMethodType::ALIPAY) {
            $method = 'Alipay';
        } elseif ($this->payment_provider_charge_method === PaymentMethodType::GRABPAY) {
            $method = 'GrabPay';
        } elseif ($this->payment_provider_charge_method === PaymentMethodType::WECHAT) {
            $method = 'Wechat Pay';
        } elseif (($card = $this->card()) instanceof Card) {
            $brand = $card->brand ? ucwords($card->brand) : 'Unknown';

            $country = strtoupper($card->country);

            $method = "{$brand} (****{$card->last_4}, {$country})";
        } elseif ($this->payment_provider_charge_method === PaymentMethodType::SHOPEE) {
            $method = 'Shopee Pay';
        } elseif ($this->payment_provider_charge_method === PaymentMethodType::GRABPAY_DIRECT) {
            $method = 'GrabPay (direct)';
        } elseif ($this->payment_provider_charge_method === PaymentMethodType::GRABPAY_PAYLATER) {
            $method = 'GrabPay PayLater';
        } elseif ($this->payment_provider_charge_method === PaymentMethodType::HOOLAH) {
            $method = 'Hoolah';
        } else {
            $method = 'Unknown';
        }

        return $method ?: '-';
    }

    /**
     * @return \Illuminate\Database\Eloquent\Relations\HasMany|\App\Business\ChargeReceiptRecipient|\App\Business\ChargeReceiptRecipient[]
     */
    public function receiptRecipients() : HasMany
    {
        return $this->hasMany(ChargeReceiptRecipient::class, 'business_charge_id', 'id');
    }

    public function isRefunded()
    {
        return $this->status === ChargeStatus::REFUNDED || $this->status === ChargeStatus::VOID;
    }

    public function isSucceeded()
    {
        return $this->status === ChargeStatus::SUCCEEDED;
    }

    /**
     * @param array $options
     * @return bool
     */
    public function save(array $options = [])
    {
        // TODO - This should be moved to "saving" event.
        //
        $this->plugin_data = $this->removeUnusedData($this->plugin_data ?? []);

        return parent::save($options);
    }

    /**
     * @param array $fields
     * @return array
     */
    public function removeUnusedData(array $fields)
    {
        $data = [];
        if (!empty($fields)) {
            foreach ($fields as $key => $value) {
                if (!in_array($key, self::REMOVING_FIELDS)
                    && !in_array(str_replace('x_', '', $key), self::REMOVING_FIELDS)) {
                    $data[$key] = $value;
                }
            }
        }

        return $data;
    }

    public function isForXeroInvoice(): bool
    {
        if(in_array($this->plugin_provider, [PluginProvider::CUSTOM, PluginProvider::XERO]) && !empty($this->plugin_provider_reference)) {
            return PaymentRequest::where('channel', PluginProvider::XERO)->where('id',$this->plugin_provider_reference)->exists();
        }

        return false;
    }

    public function getFormattedFees()
    {
        return number_format(getReadableAmountByCurrency($this->currency, $this->fixed_fee+$this->discount_fee), 2);
    }

    /**
     * @return \Illuminate\Database\Eloquent\Relations\HasMany|\App\Business\Refund|\App\Business\Refund[]
     */
    public function refunds() : HasMany
    {
        return $this->hasMany(Refund::class, 'business_charge_id', 'id');
    }

    /**
     * @return PaymentRequest
     */
    public function invoice() : HasOne
    {
        return $this->hasOne(Invoice::class, 'payment_request_id', 'plugin_provider_reference');
    }

    public function transfer() : HasOne
    {
        return $this->hasOne(Transfer::class, 'business_charge_id', 'id');
    }

    // public function setCurrencyAttribute()
    // {
    // }
    //
    // public function setAmountAttribute()
    // {
    // }
    //
    // public function setFixedFeeAttribute()
    // {
    // }
    //
    // public function setDiscountFeeAttribute()
    // {
    // }
    //
    // public function setDiscountFeeRateAttribute()
    // {
    // }

    // method - alipay, wechat pay etc.
    // temporary only, not in use anymore
    // status -  success, failed, refunded, partially refunded

    // device
    // user
    // customer

    /**
     * @return PaymentRequest
     */
    public function paymentRequest() : HasOne
    {
        return $this->hasOne(PaymentRequest::class, 'id', 'plugin_provider_reference');
    }

    /**
     * @return InvoicePartialPaymentRequest
     */
    public function invoicePartialPaymentRequest() : HasOne
    {
        return $this->hasOne(InvoicePartialPaymentRequest::class, 'payment_request_id', 'plugin_provider_reference');
    }

    public function isEligibleForCampaignCashback($forDisplay = false){
        $no_campaign = [false, 0, null, null];
        $eligibleCampaign = null;

        //get campaigns which are active and have sufficient funds
        $campaigns = CashbackCampaign::where('status', 1)->where('fund', '>', 0);

        if (!$forDisplay)
            $campaigns->where('payment_method', $this->payment_provider_charge_method);

        $campaigns = $campaigns->get();

        if (!count($campaigns)){
            return $no_campaign;
        }

        foreach ($campaigns as $campaign){
            //if campaign's payment sender not equal charge's sender, then skip this campaign
            if ($campaign->payment_sender != null && (isset($this->data['txnInfo']) && $campaign->payment_sender != $this->data['txnInfo']['senderParty']['senderBankId'])){
                continue;
            }

            $rulesWithBusiness = $campaign->rules->where('business_id', '!=', 'blanket_rule')->pluck('business_id')->toArray();

            //check if charge satisfies any of the campaign's rule
            foreach ($campaign->rules as $rule){

                //if campaign satisfies one of the rule, break the loop since we found eligible campaign
                if ($this->amount >= getRealAmountForCurrency('sgd', $rule->min_spend) && ($rule->balance_cashback > 0))
                {
                    if ($this->business_id === $rule->business_id || ($rule->business_id === 'blanket_rule' && !in_array($this->business_id, $rulesWithBusiness))) {
                        $eligibleCampaign = $campaign;
                        $eligibleRule = $rule;
                        break;
                    }
                }
            }

            if ($eligibleCampaign)
                break;
        }

        if (!$eligibleCampaign)
            return $no_campaign;

        $amountToBeRefunded = $eligibleRule->cashback_amt_fixed;
        if ($eligibleRule->cashback_amt_percent)
            $amountToBeRefunded += getReadableAmountByCurrency('sgd', $this->amount) * $eligibleRule->cashback_amt_percent / 100;

        if ($amountToBeRefunded > $eligibleRule->maximum_cap)
            $amountToBeRefunded = $eligibleRule->maximum_cap;

        if ($eligibleRule->balance_cashback > 0 && $amountToBeRefunded > $eligibleRule->balance_cashback)
            $amountToBeRefunded = $eligibleRule->balance_cashback;

        return [true, getRealAmountForCurrency('sgd', $amountToBeRefunded), $eligibleCampaign, $eligibleRule];
    }

    public function requiresPaymentMethod() : bool
    {
        return $this->status === ChargeStatus::REQUIRES_PAYMENT_METHOD;
    }

    /**
     * Get the data of Stripe card.
     *
     * @return array|null
     */
    protected function getDataStripeCard() : ?array
    {
        $isPaymentProviderStripe = in_array($this->payment_provider, [
            PaymentProviderEnum::STRIPE_MALAYSIA,
            PaymentProviderEnum::STRIPE_SINGAPORE,
        ]);

        if (!$isPaymentProviderStripe) {
            return null;
        }

        $isPaymentMethodCard = in_array($this->payment_provider_charge_method, [
            PaymentMethodType::CARD,
            PaymentMethodType::CARD_PRESENT,
        ]);

        if (!$isPaymentMethodCard) {
            return null;
        }

        $stripeCharge = $this->data['stripe']['charge'] ?? $this->data;

        return $stripeCharge['payment_method_details'][$this->payment_provider_charge_method];
    }

    /**
     * Get the card of the payment intent, if it has.
     *
     * @return \HitPay\Data\Objects\PaymentMethods\Card|null
     */
    public function card() : ?Card
    {
        if ($card = $this->getDataStripeCard()) {
            return new Card(
                $this->payment_provider_method === PaymentMethodType::CARD_PRESENT,
                $card['network'] ?? null,
                $card['brand'],
                $card['cardholder_name'] ?? null,
                $card['country'],
                $card['exp_month'],
                $card['exp_year'],
                $card['funding'],
                $card['issuer'] ?? null,
                $card['last4'],
                $card['read_method'] ?? null
            );
        }

        return null;
    }
}
